TCP状态迁移图（牢记）![TCP三次握手&四次挥手流程图](https://upload-images.jianshu.io/upload_images/25207321-c2c5b1693d5ed237.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#go语言问题
1、协程与线程的区别 (+2)
答：线程是操作系统调度的最小单位，而协程是用户态实现的轻量级线程。另外协程在实际运行时候是绑定在线程之上的，因此协程的切换开销远小于线程切换的开销，因为不需要从用户态到内核态的切换。
2、为什么协程比线程调度消耗的资源更小
答：1、线程切换程序需要从用户空间切换到内核空间（线程调度需要特权模式，只有内核空间才有）
2、线程切换需要保存更多的上下文，包括线程私有的栈指针和寄存器。

3、chan是什么，有类型类型（有缓冲和无缓冲类型）(+2)
答：chan是协程之间通信的管道，分为有缓冲和无缓冲两种类型；无缓冲chan可以实现原子化和协程的同步操作。

4、多态是什么，golang如何实现多态（多个struct实现某个interface的接口）
答：父类指针或引用去调用方法，但是在执行的时候，能够根据子类的类型去执行子类当中的方法。也就是说实现我们用相同的调用方式调出不同结果或者是功能的情况，这种情况就叫做多态。
golang通过定义一个Interface接口，里面定义一个接口要实现的方法。如果某个对象实现了该接口的全部方法，那么该对象就隐式实现了这个接口，那么我们就实现了golang的多态。

5、反射使用过么
待补充

6、微服务怎么理解，优势是什么，带来的问题是什么？
答：微服务，又叫微服务架构。微服务架构是一种架构风格，它将一个复杂的应用拆分成多个独立自治的服务，服务与服务间通过松耦合的形式交互。
优势：职责单一（逻辑清晰）、部署简化（只关心一个服务）、可扩展、灵活组合、技术异构（通过接口调用，语言可不会成为限制条件）、系统高可靠（不会因为某个功能导致程序crash）
缺点：网络开销加大，影响性能、排查链路变长、复杂度高（需要考虑服务方各种情况，比如过载、不可用、消息丢失等等）

7、API网关是什么
答：API封装了系统内部架构，有如下好处：
1）接口聚合，使得服务对调用者透明，客户端与后端的耦合度降低
2）提供通用安全功能：路由管理、负载均衡、安全校验、故障隔离、限流、熔断、A/B测试、灰度发布（流量转移）

8、满足什么条件可以支持水平扩展
待补充

9、原子操作可以实现的方法
答：golang里面可以通过：
1、无缓冲区chan
2、互斥锁
3、golang内置的sync.atomic
- [func LoadInt32(addr *int32) (val int32)](https://link.zhihu.com/?target=https%3A//golang.org/pkg/sync/atomic/%23LoadInt32)

- [func LoadInt64(addr *int64) (val int64)](https://link.zhihu.com/?target=https%3A//golang.org/pkg/sync/atomic/%23LoadInt64)

- [func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)](https://link.zhihu.com/?target=https%3A//golang.org/pkg/sync/atomic/%23LoadPointer)


10、面向对象编程和面向过程区别
待补充

11、什么是封装，有什么好处
答：封装就是将属性私有化，提供公共的方法访问私有属性。
好处：隐藏实现细节，让开发人员不需要关心如何实现；可重用性；可维护性，一个地方修改，其他调用的自动修改；

12、为什么需要队列，带来的好处是什么
答：异步化、削峰、服务解耦

13、cgo有使用过么
答：CGO提供了golang和C相互调用的机制，通过import "C"调用

14、golang map如何实现顺序读取
答：对map的key按照自定义规则重新排序，在获取map的value

15、context的作用，以及协程使用context会自动取消么
答：context主要用于goroutine之间传递上下文信息，包括：取消信号、超时时间、截止时间、kv数据

16、new 和 make的区别（返回指针和对象的区别，另外make会初始化相应类型的零值）
答：new返回类型指针，make返回的是初始化后的对象引用，make仅可以用作chan、map、slice分配内存；make参数有三个，分别是类型、长度、容量。new不可以指定长度，只有一个参数

17、 服务发现是怎么做的 （+2）

19、waitgroup和chan使用场景，分别举一个
答：waitgroup：并发执行20个协程，但是需要等待20个协程执行完毕才可以继续，可以使用waitgroup.wait()
chan：一个协程执行某个job，另一个协程等待上一个协程的结果，可以通过chan传递结果。

20、map和slice的扩容机制 （+2）(map的数据结构，get/put/delete过程，扩容机制;slice的内存结构，扩容机制，巨型slice产生的垃圾回收问题)
答：
1. append单个元素，或者append少量的多个元素，这里的少量指double之后的容量能容纳，这样就会走以下扩容流程，不足1024，双倍扩容，超过1024的，1.25倍扩容。
2. 若是append多个元素，且double后的容量不能容纳，直接使用预估的容量。

**敲重点！此外，以上两个分支得到新容量后，均需要根据slice的类型size，算出新的容量所需的内存情况capmem，然后再进行capmem向上取整，得到新的所需内存，除上类型size，得到真正的最终容量,作为新的slice的容量。**

这个值等于实际申请的内存大小：fmt.Println(unsafe.Sizeof(&s))

21、go并发模型：MPG模型和CSP模型
简答：
        全局队列（Global Queue）：存放等待运行的 G。P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G时，G优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。
P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。
M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。
CSP 是 Communicating Sequential Process 的简称，中文可以叫做通信顺序进程，是一种并发编程模型，Go语言的CSP模型是由协程Goroutine与通道Channel实现。

衍生问题：runtime.GOMAXPROCS(32)这个函数改变的是P还是M的值？
答：改变的是P的值。M与P一般是一一对应的，但是如果某个线程执行Blocking操作，会导致可用的M减少，这个时候，Go的调度策略会创建一个新的线程绑定P；等待之前Blocking的线程可用时候，会把这个线程加入可调度的线程队列。所以Go程序在运行一段时间后，有可能M > P。

22、golang发协程调度模型是抢占式还是非抢占式（1.14之后是基于信号的抢占式调度，那么golang还有哪些抢占调度机制呢？其实是有的，而且满足大部分的场景，但是某些机端场景不会被触发）
答：go最开始的抢占式调度是通过后台起一个sysmon线程（是线程，不受go runtime协程调度模型控制）监控协程是否占用时间过长，如果过长会对当前的协议做个标记，然后等待触发条件满足，runtime会去调度。问题：协程调度的条件是：函数调用、sleep、io等待，但是如果一个协程只有空循环，一直不满足条件，那么这个协程会一直占用一个线程。
因此，1.14后，golang引入了基于信号的抢占式调度，解决之前某些极端场景。

23、golang的GC了解么
答：MarkWorker goroutine递归扫描所有对象，并将它们着色为白色（不可访问），灰色（待处理），黑色（可访问）。但最终它们只会是黑白对象。 在编译时，编译器已经注入了一个称为写屏障的代码片段，以监视从任何goroutine到堆内存的所有修改。 当执行“ Stop the world”时，调度程序将休眠所有线程并抢占所有goroutine。 垃圾收集器将回收所有无法访问的对象，以便堆或中央对象可以重用。 如果未使用全部内存，则可以将其释放给OS。 执行“启动世界”以唤醒CPU内核和线程，并继续执行goroutine。

24、defer及其用法
25、golang的性能诊断工具（goroutings、memory、cpu）

26、读一个已经关闭的chan会怎么样？
答：读取会成功，返回这个类型的零值，如果使用for select去读取，会陷入死循环。

27、如果子的context重写了context的timeout时间，那么子的context会受父context超时影响么？
答：父的context会影响所有子的context，无论子的context是否重写timeout时间，但是子的context不会影响到父context，即使手动调用cancel()也不会影响。

28、context的WithValue方法，子context可以获取父context的值么？父context可以获取子context的值么？
答：ctx := context.WithValue(context.Background(),"name","tom")使用形式如上。
context只能自上而下携带值，也就是子可以获取父的值，但是父不能获取子的值。
context取消（cancel）过程也是自顶向下依次取消，依次通知子context超时取消。
参考：https://xie.infoq.cn/article/3e18dd6d335d1a6ab552a88e8

29、如何声明只读只写的chan
答：默认chan类型是可读可写的
type readChan <-chan int                  //只读chan  
type writeChan chan <-int                  //只写chan

30、fmt.Printf("%d\n",00010)输出结果是什么？
答：结果是8
%d代表按照十进制打印结果，但是00010会当作八进制，因为0是八进制开头标志，0x十六进制，所以如果我们需要用十进制表示的话，一定不能以000开头。

31 哪些变量是不能被传递的？带状态？mutex
32 切片在使用时候有哪些注意事项？
33 k8s健康检查有哪些，分别有什么区别
33 k8s健康检验
34 k8s configmap

31、简单介绍下golang运行时内存策略
答：对于小于 32KB的对象，runtime首先从缓存开始，依次central、堆，如果对象大于32KB直接分配堆内存。

32、nil切片和空切片区别
nil切片：var s1 []int
空切片：var s2 = make([]int,0)     
var s3 = make([]int,0)
答：nil切片底层引用数组指针指向0x0，没有指向任何实际地址，空切片的底层引用数组指针指向一个固定的值。其实就是如果一个切片初始化了，但是没有任何容量，就为它指向一个全局共用的长度为0的数组地址。
type SliceHeader struct {
 Data uintptr  //引用数组指针地址
 Len  int     // 切片的目前使用长度
 Cap  int     // 切片的容量
}

33、字符串转成byte切片会发生内存拷贝么？
答：字符串转成切片会产生拷贝，严格来说，所以数据类型强转都会发生内存拷贝。

34、如何避免字符串在转换成切片的时候不发生拷贝呢？（频繁内存拷贝影响性能）
先来看下String类型在golang底层的数据结构
type StringHeader struct {
 Data uintptr
 Len  int
}
再对比下Slice的底层数据结构，切片只多出了容量字段，因此强转的时候可以将内容和长度字段强转成功的。
具体操作中需要使用unsafe.Pointer()函数，将字符串的地址拿到并转换成ArbitraryType类型（任意类型），然后将任意类型强转成*reflect.StringHeader String底层数据类型指针。同理将该指针再强转成byte切片类型即可。
注意点：golang 不支持将内置的数据结构类型（String 、int）直接强转成底层数据结构类型（StringHeader），因此这个问题的关键就是如何转换成任意类型，再强转成切片和String的底层数据结构类型即可。
问题：这种方式获得的切片缺少容量字段，这个字段为1，因为string类型底层数据结构是没有该字段的。

35、如何翻转含有中文、数字、字母的字符串？
答：考点rune类型，它是int32的别名，比起byte可以表示更多的字符，rune可以表示的字符范围很大，包含中文字符。因此首先将字符串转换成rune切片再反转即可。

36、在for循环内append数据会造成死循环么？
代码：
for _,v := range s{
    s = append(s,v)
}
答案：不会，因为range其实是go的语法糖，它在循环执行的时候已经确定好循环的次数（len(s)），并不是边循环边取值。
代码会被编译成：for index_temp := 0;*** index_temp < len_temp***; index_temp++ {
  value_temp := for_temp[index_temp]
  _ = index_temp
  value := value_temp
  // 以下是 original body 我们注入的代码块
  s =append(s, value)
  fmt.Printf("len(s)=%v\n",len(s))
 }
}

37、谈谈内存逃逸，什么情况下会发生内存逃逸？
答：golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在堆上分配。

- **在方法内把局部变量指针返回** 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
- **发送指针或带有指针的值到 channel 中。** 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。
- **在一个切片上存储指针或带指针的值。** 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
- **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
- **在 interface 类型上调用方法。** 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。

38、怎么避免内存逃逸？
答：内存逃逸是Golang runtime一个功能，主要用于检测一个变量内存分配是在堆上还是栈上。如果一个变量被其他函数引用，那么runtime会把该变量标记逃逸，然后内存会从堆上分配。
如何避免编译器标记呢？也就是如何让变量内存分配在栈上（栈访问速度是大于堆的，所以栈内存访问存在一定优势），那就是使用noescape()函数，noescape() 函数的作用是遮蔽输入和输出的依赖关系。使编译器不认为 p 会通过 x 逃逸， 因为 uintptr() 产生的引用是编译器无法理解的。

39、拷贝大切片一定比小切片代价大吗？
答：首先切片拷贝分为***浅拷贝***和***深拷贝***
浅拷贝：s2 := s1[0:] //共享底层数组，也就是数据Data部分指向同一个内存块
深拷贝：s2 := make([]int,5) copy(s2,s1) //s2新开辟了一段内存块，然后通过内置函数copy将s1的data部分拷贝到s2 data部分。
大切片跟小切片的区别无非就是 Len 和 Cap的值比小切片的这两个值大一些，如果发生拷贝，本质上就是拷贝上面的三个字段。所以 ***拷贝大切片跟小切片的代价应该是一样的。***

40、map不初始化长度和初始化长度的区别
答：都是0

41、map的iterator是否安全？能不能一边delete一边遍历？
答：map的遍历不是线程安全的，当只有一个协程进行map的读写操作时候是可以遍历删除，但是如果并发情况下，是不可以的，会随机出现panic，因为对某一个元素的读写同时进行。线程安全的map结构推荐使用sync.Map，也可以手动加读写锁。

42、字符串不能改，那转成数组能改吗，怎么改
答：golang的字符串类型是
```
type StringHeader struct {
	Data uintptr
	Len  int
}
```
这里说的不能修改指的是不能s[0] = 'a'（通过下标直接修改内存位的值）
可以通过将string类型强转成rune切片类型（rune类型是int32的别名）
```
s3 := []rune(s)
s3[0] = 'w'
fmt.Printf("%c\n",s3)
```

43、怎么判断一个数组是否已经排序？
答：内置类型比如Int类型数组排序可以通过sort.Ints()排序，判断Int数组是否已经排序。如果是自定义数据类型，需要实现less() 、swap()、len()三个方法，然后通过sort.IsSorted()判断数组已经排序。

44、普通map如何不用锁解决协程安全问题
答：不用锁解决的话，那就是自定义封装一个数据结构，包含map，然后将读写操作通过安全的方式进行，再将结果返回即可。安全的方式要么就是采用内置从sync.Map或者将读写操作操作通过管道的方式传递，单线程执行操作即可，这样肯定不会存在安全问题（借鉴Redis命令执行的涉及）。这里也实践了go的一个原则，即通过通信去共享变量。
//存在的性能瓶颈，就是chan的大小问题，如果读场景很多的话可以开多个线程处理chan，那么随之而来的问题就是线程安全问题，可以将key散列到不同线程处理，同个线程是不会存在安全问题的
//第二个瓶颈是如果写的少读的多，避免chan的阻塞（chan缓冲区打满，需要阻塞等待），那么可以扩大chan的容量，因为写入是不需要等待的。
```
type MyMap struct {
	data map[int]int
	c chan interface{}
}

type Optype int
const (
	Read Optype = iota
	Write
)
type Op struct {
	Op Optype
	Res chan interface{}
	Key int
	Value int
}

func (m MyMap)Start()  {
	defer fmt.Println("map stop...")
	for op := range m.c{
		o := op.(Op)
		switch o.Op{
		case Read:
			o.Res <- m.data[o.Key]
		case Write:
			m.data[o.Key] = o.Value
		}
	}
}

func (m MyMap)Stop()  {
	close(m.c)
}

func (m MyMap)Read(key int) int{
	op := Op{
		Op: Read,
		Res: make(chan interface{}),
		Key: key,
	}
	m.c <- op
	return (<-op.Res).(int)
}

func (m MyMap)Write(key int,value int){
	op := Op{
		Op: Write,
		Key: key,
		Value: value,
	}
	m.c <- op
	return
}
```
45、json包里使用的时候，结构体里的变量不加tag能不能正常转成json里的字段？
答：1、如果变量首字母小写，则为私有属性，无论如何不能转，因为取不到反射信息。
2、如果变量首字母大写，则为public
- 不加tag，可以正常转为json里的字段，json内字段名跟结构体字段原名一致
- 加了tag，从struct转json的时候，json的字段名就是tag里的字段名，原字段名已经没用。

46、零切片、空切片、nil切片区别
答：零切片是指切片元素都是该类型的零值，跟长度无关
空切片是初始化了，但是长度和容量都为0，即没有分配任何内存
nil切片是指没用初始化的切片，data部分指向0x0地址，不可访问

47、golang的map扩容过程
答：
golang map底层数据结构
```
// A header for a Go map.
type hmap struct {
    // 元素个数，调用 len(map) 时，直接返回此值
    count     int
    flags     uint8
    // buckets 的对数 log_2
    B         uint8
    // overflow 的 bucket 近似数
    noverflow uint16
    // 计算 key 的哈希的时候会传入哈希函数
    hash0     uint32
    // 指向 buckets 数组，大小为 2^B
    // 如果元素个数为0，就为 nil
    buckets    unsafe.Pointer
    // 扩容的时候，buckets 长度会是 oldbuckets 的两倍
    oldbuckets unsafe.Pointer
    // 指示扩容进度，小于此地址的 buckets 迁移完成
    nevacuate  uintptr
    extra *mapextra // optional fields
}
```
背景：map的底层数据结构其实就是hash表，理想情况下每个key占用一个一个哈希槽，这种查询效率是最快的。但是实际情况是没有真正完全散列的哈希算法以及无穷无尽的hash槽，因此就会存在哈希冲突的办法，golang的map处理冲突的办法是槽下挂链。
真正答案：扩容时机：在向map插入新的key的时候，会进行扩容条件检测，符合以下任意一种条件即会产生扩容。
- 装载因子超过阈值，Goang源码定义的阈值是6.5
>装载因子 = 元素个数 (count) / 桶个数 (2 ^ B)

**双倍扩容：**装载因子过大，直接翻倍（因为这个条件满足，直接代表hash表不够用了，理应扩容）；扩容不是申请一块内存，立刻开始拷贝，，每次访问旧的buckets时候，就迁移一部分，直到全部完成，旧的buckets被GC回收。
- overflow的bucket数量过多
>这种情况一般是哈希冲突的key比较多，数据都挂在同一个哈希槽下，但是整个哈希表的使用不是很多（其他槽节点下很空）。这种情况触发的场景通常是经常一次性插入很多元素，再删除，再插入很多哈希冲突的元素。

**等量扩容：**哈希表的大小完全够用，只不过挂在某个Buckets下面的冲突元素太多，这个时候需要重新对哈希槽下面的元素进行重新排列，即利用已经分配内存，但是目前已经被删除的元素的位置。让一个哈希槽下面的元素尽可能的排列紧密。（这种场景有个极端情况，即插入的key都落在一个槽，并且元素也不删，那么这个时候查询这个槽下面的key复杂度确实很高了o(n) ，因为这个时候完全退化成链表查询。）

48、map的遍历是有序还是无序，为什么？
答：map的遍历是无序的，原因如下
1.  map会产生扩容，原本一个槽下的key扩容后会分流到不同的槽节点
2. go遍历hash表的时候没有固定从0号buckets开始，而是随机选一个Buckets序号开始，并且遍历一个buckets下面的元素时候，也是随机选一个cell开始遍历

因此map的遍历完全是随机的。

49、map里面常用的一些术语概念
1. go语言通过哈希表实现map，用链表解决哈希冲突
2. 扩容过程是渐进的，主要防止一次扩容需要迁移的key过多导致性能问题。触发扩容的时机是增加了新元素，bucket搬迁的时机则发生在赋值、删除期间，每次最多搬移2个bucket
3、通过key的哈希值将key散列到不同的桶中，每个桶中最多能存储8个cell。哈希值的低位（具体低多少位由B决定）决定桶序号，高位标识桶一个桶中的不同key。
B是uint8，最大为255，那么buckets长度（z ^ B）理论上最大有 2 ^ 255。

50、当一个对象是引用类型时候，使用需要注意什么？
答：当一个对象是引用类型时候，如果底层数据还会被其他地方使用，并且有可能会改变其值，那么尽量使用深拷贝拷贝对象。即新建一个底层数据结构，然后拷贝原来的值，而不是新建一个对象，然后将底层数据结构的指针指向同一块地址。

51、golang如何原子的修改一个数字，不使用锁
答：golang的sync/atomic包提供原子化操作方法
方法：CompareAndSwapInt32（Compare And Swap 简称CAS）
功能：比较并修改一个元素的值。
简述：它是假设被操作的值未曾被改变（即与旧值相等），并一旦确定这个假设的真实性就立即执行替换操作。如果想并发修改一些类型的值，应该优先使用CAS。这个方法的返回值是修改是否成功。不会阻塞。使用的时候配合atomic.LoadInt32(&c)函数，保证当前变量没用被其他地方正在修改操作。

52、map的value可以寻址么
答：如果map存储的是对象不是指针，不能对该对象直接赋值修改，因为该对象地址在内存中是会移动的，归根到底是值拷贝导致的。如果需要改变map中的value，可以存储对象指针。

53、如果设置runtime.GOMAXPROCS(1) 协程的执行顺序如何？
答：这个输出结果决定来⾃于调度器优先调度哪个G。从runtime的源码可以看到，当创建⼀个G时，会优先放⼊到下⼀个调度的 runnext 字段上作为下⼀次优先调度的G。因此，最先执行的是最后创建的G。剩余的协程则按照先进先出的顺序执行。

54、切片append位置
答：append如果不指定位置，将从len字段索引处往后追加。

55、切片浅拷贝内容
s1 := []int{1,2}
s2 := s1[:]
{Data:0x824636252448 Len:2 Cap:2}
浅拷贝拷贝了底层数组地址，len字段和cap字段是拷贝了值，不跟原来切片复用。

#中间件问题
1、es为什么查询比别的数据库快
2、zipkin了解
3、redis和mongodb的区别
4、mongodb的理解
5、rabbitmq的amqp协议了解么
6、熔断限流是怎么做的
7、rabbitmq 参数prefetchCount有什么作用（说明中间件的理解最起码要了解到每个方法及常用的参数含义）
8、ES的倒排索引是什么
9、redis的五种数据类型以及底层实现是什么
答：string、list、set、zset、hash
string（set、get、decr、incr、mget）：数据结构：redis自己封装的SDS，SDS多了该对象剩余字节和已使用字节，在获取长度的场景中效率比较高；value可以是string或者数字；常规场景：常规计数：微博数、粉丝数
hash（hget、hset、hgetall）：数据结构ziplist（压缩列表）和hashtable；适合存储对象，后续操作直接仅仅修改某个对象的某个字段的值。常用场景：存储用户信息、商品信息
list（lpush、lpop、rpush、rpop、lrange）：数据结构：双向链表，支持反向查找遍历；常用场景：粉丝列表、关注列表、消息列表；另外可以基于redis实现高性能分页，类似微博那种不断下拉不断分页的效果。
set（sadd、spop、smembers、sunion）：底层数据结构：intset和hashtable两种数据结构；set提供的功能与list类似，都是列表的功能，但是set能够自动去重，当需要存储一个列表数据但是不希望出现重复数据时候，可以使用set。基于set可以轻松实现交集、并集、差集的操作。常用的场景：共同关注人，共同粉丝等等
sort set(zset)：底层数据结构：ziplist或skiplist；和set相比，sort set多了一个权重参数score，可以使得集合中的元素按照score进行有序排序。使用场景：礼物排行榜
10、time_wait状态很多以及解决方式
11、redis的内存淘汰机制是什么（策略可以配置的）
同下。

12、redis如果内存满了怎么办？
答：redis的内存大小可以配置，如果内存超过配置上限，那么redis则根据配置的内存淘汰机制进行处理，淘汰机制有以下6种：
 Redis提供6种数据淘汰策略：
1）volatile-lru:从已设置过期时间的内存数据集中挑选最近最少使用的数据 淘汰；
2）volatile-ttl: 从已设置过期时间的内存数据集中挑选即将过期的数据 淘汰；
3）volatile-random:从已设置过期时间的内存数据集中任意挑选数据 淘汰；
4）allkeys-lru:从内存数据集中挑选最近最少使用的数据 淘汰；
5）allkeys-random:从数据集中任意挑选数据 淘汰；
6）no-enviction(驱逐)：禁止驱逐数据。（默认淘汰策略。当redis内存数据达到maxmemory，在该策略下，直接返回OOM错误）
默认策略是驱逐，直接返回OOM错误。

13、Mysql的事务索引了解么
14、redis删除过期键的策略
答：在Redis种有三种删除的操作此策略，分别是：
定时删除：创建一个定时器，定时的执行对key的删除操作。（对CPU不友好，程序需要额外维持定时器，占用CPU资源）
惰性删除：每次只有再访问key的时候，才会检查key的过期时间，若是已经过期了就执行删除。（对内存不友好，不被访问的key会一直占用内存）
定期删除：每隔一段时间，就会检查删除掉过期的key。（折中方案，根据具体业务，选取合理的删除间隔）

15、redis的同步机制
答：主从同步。第一次同步时候，「主节点做一次bgsave」，并同时将后续修改操作记录到「内存buffer」，待完成后「将rdb文件全量同步到复制节点」，复制节点接受完成后「将rdb镜像加载到内存」。加载完成后，再通知主节点「将期间修改的操作记录同步到复制节点进行重放」就完成了同步过程。

16、redis哨兵和集群的区别
答：哨兵更注重高可用，主节点挂了，从节点成为主节点，主从关系使用链式关系，不要使用图式关系。集群更注重可扩展性，单个redis内存不足时候，使用Cluster进行分片存储。

17、kafka是怎么体现顺序消费的？
答：kafka每个partition中的消息在写入时都是有序的，消费时，每个partition只能被每一个group中的一个消费者消费，保证了消费时也是有序的。
整个topic不保证有序。如果为了保证topic整个有序，那么将partition调整为1。

18、redis的hash结构使用过么？
待补充

19、如何设计一个秒杀的接口？
待补充

20、如何理解redis是单线程的说法？
答：redis中只有核心网络请求模块以及键值对（数据）操作模块是单线程，其他的模块比如持久化模块和集群支撑模块是多线程。

21、为什么网络模块和数据操作模块使用单线程？
1）redis操作基于内存，绝大多数的操作性能瓶颈不在于CPU
2）使用单线程模型，可维护性更高，开发调试维护的成本更低
3）单线程模型避免了线程间切换的开销
4）I/O多路复用技术也能提高Redis的I/O利用率

22、什么是I/O多路复用？
答：多个线程的IO（fd文件描述符）注册到同一个管道，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间。也就是说通过一个线程来处理多个IO流。

23、mysql乐观锁和悲观锁？
答：
悲观锁：顾名思义，就是对于数据的处理持悲观态度，总认为会发生并发冲突，获取和修改数据时，别人会修改数据。所以在整个数据处理过程中，需要将数据锁定。
悲观锁的实现，通常依靠数据库提供的锁机制实现，比如mysql的排他锁，select .... for update来实现悲观锁。

乐观锁：顾名思义，就是对数据的处理持乐观态度，乐观的认为数据一般情况下不会发生冲突，只有提交数据更新时，才会对数据是否冲突进行检测。
如果发现冲突了，则返回错误信息给用户，让用户自已决定如何操作。
乐观锁的实现不依靠数据库提供的锁机制，需要我们自已实现，实现方式一般是记录数据版本，一种是通过版本号，一种是通过时间戳。
给表加一个版本号或时间戳的字段，读取数据时，将版本号一同读出，数据更新时，将版本号加1。
当我们提交数据更新时，判断当前的版本号与第一次读取出来的版本号是否相等。如果相等，则予以更新，否则认为数据过期，拒绝更新，让用户重新操作。

24、redis可以设置数据隔离么？不使用多个redis。
答：redis可以使用多个DB来隔离数据，做到key不冲突；redis连接默认使用的是索引为0的DB，可以在连接redis的时候指定DB的值。DB的个数在配置文件中通过 databases字段指定（示例：databases 16）。

#微服务
1、微服务你了解么
2、golang的微服务框架有了解么
答：go micro、go kit、gizmo、kite

3、服务发现是怎么做的

#HTTP协议
1、http2.0和http1.x区别，golang是如何实现http2.0的 （+3）（除了长连接，尽量多了解下其他的一些变化）
答：http2.0添加头部压缩、服务器推送、多路复用

2、HTTP层是如何解析属于自己的字节的

#系统排查
1、Linux性能排查有经验么？比如：CPU和内存过高
2、僵尸进程和孤儿进程的区别
答：孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

　　僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

总结：父进程先于子进程退出，子进程是孤儿进程，会被init进程接管，负责子进程的资源回收（文件描述符）；父进程没有退出，但是没有调用wait或者waitpid方法获取子进程的信息，那么退出的子进程就是僵尸进程。
3、系统负载过高怎么排查，load的值是怎么计算的？
4、内存cache、buffer、res区别
5、如果频繁调度apiserver，哪些地方可能会出现瓶颈？

#网络问题
1、close_wait状态最根本的原因是什么

答：close_wait是被动关闭方的一个状态，它开始于收到对方的FIN包，并发出FIN_ACK后并且在调用cliose之前的一个临时状态。这种状态存在的***根本原因是被动方没有及时调用close关闭连接***。至于为什么没有调用close有以下两种可能原因：

1. 被动方在close之前的操作时间太长，以至于close_wait状态维持时间较长，导致较多
2. 被动方根本没有调用close方法，可能是逻辑漏洞或者陷入某种死循环

2、time_wait状态的最根本原因是什么？及如何解决
答：time_wait是TCP四次挥手过程中***主动关闭方的一个状态***（即主动调用close方法），它***开始于收到对方的FIN包之后***（也就是对方也调用close），自己发出最后的FIN_ACK之后的一个状态，这个***状态维持最长时间2MSL***。目的是为了保证自己发出的FIN_ACK能够被对方正确接收，保证对方连接正确关闭。
如何解决：
1、fd重用（setsockoption）
2、调大端口范围（不解决根本问题）
3、缩短time_wait时长

3、为什么TIME_WAIT存在的时间是2MSL？
答：2MSL状态存活时间能够***保证在自己的FIN_ACK包在网络中丢失的情况下，对方能够正确重发最后的FIN包***，两个数据包在网络中最长的存活时间就是2MSL。如果主动方没有保持2MSL的时长，那么对方重发FIN包的时候，就会收到RST包，代表 连接出错，那么全双工的TCP连接就不能正确关闭。

3、三次挥手和四次挥手过程
4、TCP半连接队列和全连接队列了解么
答：在握手阶段存在两个队列：全连接队列(accept queue)、半连接队列(syns queue)
解析：当第一次握手(client客户端的SYN到达server服务端时)TCP会在未完成连接队列中创建一个新项，这一项会一直保留在未完成连接队列中直到第三次握手(客户对服务器SYN的ACK)结束为止。如果三次握手全部正常完成，该项则会从未完成连接队列移到已完成连接队列的队尾。当进程调用accept()时，已完成连接队列中的队头项将返回给进程。
参考：https://network.51cto.com/art/201909/602942.htm

5、DNS劫持和DNS污染
答：DNS劫持就是指用户访问一个被标记的地址时，DNS服务器故意将此地址指向一个错误的IP地址的行为。范例，网通、电信、铁通的某些用户有时候会发现自己打算访问一个地址，却被转向了各种推送广告等网站，这就是DNS劫持。
　　DNS污染，指的是用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。范例，访问YouTube、Facebook之类网站等出现的状况。

6、 ci工作流

7 、k8s资源隔离怎么做的

8、webhook使用过么
9、k8s健康检查？
答：k8s的健康检查分为liveness和readness
liveness检查失败，会根据重启策略，重启pod，readness如果检验失败会把endpoint移出服务的后端列表，不再接收请求。
更多参考：https://www.kubernetes.org.cn/2597.html
https://www.bookstack.cn/read/kubernetes-practice-guide/troubleshooting-problems-pod-healthcheck-failed.md

#K8S面试
![K8S整体架构图](https://pic3.zhimg.com/v2-c571e81ab75e16ecb667aa1edfc7e5ee_r.jpg)
1、K8S各个组件及其作用
 - ETCD ：是用来存储所有 Kubernetes 的集群状态的，它除了具备状态存储的功能，还有事件监听和订阅、Leader选举的功能，所谓事件监听和订阅，各个其他组件通信，都并不是互相调用 API 来完成的，而是把状态写入 ETCD（相当于写入一个消息），其他组件通过监听 ETCD 的状态的的变化（相当于订阅消息），然后做后续的处理，然后再一次把更新的数据写入 ETCD。所谓 Leader 选举，其它一些组件比如 Scheduler，为了做实现高可用，通过 ETCD 从多个（通常是3个）实例里面选举出来一个做Master，其他都是Standby。

 - API Server：刚才说了 ETCD 是整个系统的最核心，所有组件之间通信都需要通过 ETCD，实际上，他们并不是直接访问 ETCD，而是访问一个代理，这个代理是通过标准的RESTFul API，重新封装了对 ETCD 接口调用，除此之外，这个代理还实现了一些附加功能，比如身份的认证、缓存等。这个代理就是 API Server。

 - Controller Manager：是实现任务的调度的，关于任务调度你可以参考之前的文章，简单说，直接请求 Kubernetes 做调度的都是任务，比如比如 Deployment 、Deamon Set 或者 Job，每一个任务请求发送给Kubernetes之后，都是由Controller Manager来处理的，每一个任务类型对应一个Controller Manager，比如 Deployment对应一个叫做 Deployment Controller，DaemonSet 对应一个 DaemonSet Controller。

 - Scheduler：是用来做资源调度的（具体资源调度的含义请参考之前的文章），Controller Manager会把任务对资源要求，其实就是Pod，写入到ETCD里面，Scheduler监听到有新的资源需要调度（新的Pod），就会根据整个集群的状态，给Pod分配到具体的节点上。

 - Kubelet：是一个Agent，运行在每一个节点上，它会监听ETCD中的Pod信息，发现有分配给它所在节点的Pod需要运行，就在节点上运行相应的Pod，并且把状态更新回到ETCD。

 - Kubectl: 是一个命令行工具，它会调用 API Server发送请求写入状态到ETCD，或者查询ETCD的状态。

1、k8s 创建一个pod的详细流程，涉及的组件怎么通信的？
答：
(1) 客户端创建请求并通过api-server提供的restful接口提交请求。（客户端也可以是kubectl，提交的数据类型可以是JSON或者YAML）
(2) api-server处理用户请求，将Pod信息存储至etcd
(3) kube-scheduler 通过 api-server 提供的接口监控到未绑定的 pod，尝试为 pod 分配 node 节点，主要分为两个阶段，预选阶段和优选阶段，其中预选阶段是遍历所有的 node 节点，根据策略筛选出候选节点，而优选阶段是在第一步的基础上，为每一个候选节点进行打分，分数最高者胜出。
(4) 选择分数最高的节点，进行 pod binding 操作，并将结果存储至 etcd 中。
(5) 随后目标节点的 kubelet 进程通过 api-server 提供的接口监测到 kube-scheduler 产生的 pod 绑定事件，然后从 etcd 获取 pod 清单，下载镜像并启动容器。

2、网络栈具体包含了哪些内容？
答：所谓的网络栈包含了：网卡、回环设备、路由表、iptables规则。对于一个进程来说，这些要素，其实就构成了它发起和响应网络请求的基本环境。

3、docker容器之间是如何通信的
答：
基本原理：docker默认在宿主机上创建一个docker0网桥，用于转发容器间的网路流量。容器内部通过veth pair的方式，将一个网卡设备两端，一个挂在容器内部，另一个挂载在docker0网桥上。这样容器就可以通过docker0网桥进行通信。容器内部网卡通过ARP协议知道对端的MAC地址。
>备注：ARP（Address Resolution Protocol），是通过三层的 IP 地址找到对应的二层 MAC 地址的协议。

>一旦一张虚拟网卡被“插”在网桥上，它就会变成该网桥的“从设备”。从设备会被“剥夺”调用网络协议栈处理数据包的资格，从而“降级”成为网桥上的一个端口。而这个端口唯一的作用，就是接收流入的数据包，然后把这些数据包的“生杀大权”（比如转发或者丢弃），全部交给对应的网桥。

4、docker镜像是如何构建的
5、k8s deployment和stafulset区别
6、浏览器请求过程
7、docker file add copy区别
答：copy纯粹是文件复制；ADD会自动下载和解压压缩文件，一般不使用ADD
8、docker cmd 和entrypoint区别
答：CMD会直接覆盖容器启动命令；entrypoint会把启动命令追加到尾部执行。

9、docker file优化
答：因为dockerfile是分层构建，每次变化都会产生新的镜像层，因为我们可以将命令串联，减少分层。

10、k8s组件，kubelet的功能
11、k8s schedule组件如果调度能力不满足需求怎么办
12、golang的chan是如何实现的
13、golang map类型能存哪些类型的key，可以是chan么，可以是指针么
14、golang的mutex锁是如何做到不饥饿的
答：CAS（CompareAndSwap）和排队机制；如果发现如果已经有线程获取了锁，但是在当前线程在多次轮询获取锁失败的时候，就没有必要再继续进行反复尝试浪费系统资源，通常就会采用一种排队机制，来进行排队等待。

15、golang 有可以本协程无限自入的锁么
16、golang map会缩容吗
答：不会，只能手动缩容，就是新建一个map，然后range老的map，不断塞数据。

17、docker和docker shim区别
18、如果需要使用包里面隐藏的函数
详细过程：
假设存在container-1（172.17.0.3）和container-2（172.17.0.4）
（1）在c1中 ping 172.17.0.4，数据包根据容器内部的路由规则，将包交给网卡eth0，这个时候还不知道对方的MAC地址，因此会通过eth0网卡发送ARP地址解析广播
（2）eth0的另一端连接在docker0网桥上，网桥将这个ARP消息转发给IP地址为172.17.0.4的容器，回复响应的MAC地址给c1。
（3）有了这个MAC地址，c1的网卡就能把数据包发出去
（4）数据包到达docker0之后，docker0会查询mac地址对应的网桥上面的端口，然后将数据包转发给这个端口
（5）c2容器内部收到这个数据包后会恢复PONG消息。
19、envoy配置文件下发是如何保证顺序的
答：一般来说，为了避免Envoy配置数据更新过程中出现流量丢失的情况，xDS接口应采用下面的顺序：

CDS 首先更新Cluster数据（如果有变化）
EDS 更新相应Cluster的Endpoint信息（如果有变化）
LDS 更新CDS/EDS相应的Listener。
RDS 最后更新新增Listener相关的Route配置。
删除不再使用的CDS cluster和 EDS endpoints。

20、golang的map的key可以是哪些类型？
答：map中的key可以是任何的类型，只要它的值能比较是否相等，Go的[语言规范](http://golang.org/ref/spec#Comparison_operators)已精确定义，Key的类型可以是：
布尔值 、数字 、字符串 、指针、通道、接口类型、结构体、只包含上述类型的数组。***除了：slice、map、function***（只要能通过== 或者 != 进行比较的都可以作为key）

21、chan底层实现是什么？如何保证数据传递过程中不会被改变？

22、golang的gc触发时机
答：定时调用、分配内存时调用（阈值触发）、手动调用

23、观察下列代码输出
```
array1 := [3][]string{
		make([]string,0,4),
		[]string{"c", "d"},
		[]string{"e", "f"},
	}
	fmt.Printf("%p \n",array1[0])

	fmt.Println(array1[0])

	f := func(arr [3][]string) {
		fmt.Printf("%p \n",arr[0])
		fmt.Println(arr[0])
		//arr[0][0] = "c"
		arr[0] = append(arr[0], "c")
		fmt.Printf("%p \n",arr[0])
		fmt.Println(arr[0])
	}

	f(array1)

	fmt.Printf("%p \n",array1[0])
	fmt.Println(array1[0])
```
答：输出还是空
分析：
两个关键点：
- golang数组传参是开辟新空间，然后将元素一个个拷贝到新地址（也是值拷贝）
- array1指向的***底层数组没有扩容***
- array1底层数组内容确实已经变化了

原因：append操作之所以要接收返回值，有以下原因
- 底层数组的地址变化，切片引用需要指向新的底层数组地址
- slice的len字段发生了改变

上述打印内容之所以没变，就是命中了第二个原因，调用方内部的len字段发生了变化，但是这个字段属于arr变量，带不出来，arr和array1共用的变量内容只有Data底层数组的地址。因此打印的时候，会根据len的值进行打印，此刻len 还是为0，所以打印为空。

如何修改：
加一句：(*reflect.SliceHeader)(unsafe.Pointer(&s)).Len = 1

24、什么是是时序数据库？
答：时序数据是基于时间一系列的数据。时序数据库就是存储时序数据的数据库。

25、k8s的三层网络
答：k8s的三层网络方案有Flannel的host-gw和Calico项目。
**Flannel的host-gw：**flanneld插件会在宿主机上面插创建路由规则，负责将本node上面的container数据包转发到指定node。也就是说，这台“主机”（Host）会充当这条容器通信路径里的“网关”（Gateway）。这也正是“host-gw”的含义。
当然，Flannel 子网和主机的信息，都是保存在 Etcd 当中的。flanneld 只需要 WACTH 这些数据的变化，然后实时更新路由表即可。
**优势：**相比VXLAN隧道机制的网络方案，容器通信的过程免除了额外的**封包和解包带**来的额外性能消耗。
**限制条件：**host-gw能够正常工作的核心就在于IP包在封装成帧出去的时候，会使用路由表里的下一跳来设置目的MAC地址。它就会经过二层网络到达目的宿主机。

Calico：Calico 项目提供的网络解决方案，与 Flannel 的 host-gw 模式，几乎是完全一样的。也就是说，Calico 也会在每台宿主机上，添加一个格式如下所示的路由规则：
>< 目的容器 IP 地址段 > via < 网关的 IP 地址 > dev eth0

其中，网关的 IP 地址，正是目的容器所在宿主机的 IP 地址。
而正如前所述，这个三层网络方案得以正常工作的核心，是为每个容器的 IP 地址，找到它所对应的、“下一跳”的网关。
不过，不同于 Flannel 通过 Etcd 和宿主机上的 flanneld 来维护路由信息的做法，Calico 项目使用了一个“重型武器”来自动地在整个集群中分发路由信息。

这个“重型武器”，就是 BGP。
**BGP 的全称是 Border Gateway Protocol，即：边界网关协议。**它是一个 Linux 内核原生就支持的、专门用在大规模数据中心里维护不同的“自治系统”之间路由信息的、无中心的路由协议。

26、HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？
- HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接
- HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，因为传-输格式是文本的，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞
- HTTP/2多个请求可同时在一个连接上并行执行（由于支持二进制的格式，可以无序）某个请求任务耗时严重，不会影响到其它连接的正常执行

#个人发展问题
1、对比两份工作，你觉得进步收获最大的一个项目是什么

